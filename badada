#!/usr/bin/env python
# -*- coding: utf-8 -*- 

import argparse
import frida
import sys
import time
import subprocess
import os
import cmd


class FridaProcess:
    def __init__(self):
        pass

    @staticmethod
    def run():
        cmd_check_frida = 'adb shell "ps -ef" | grep frida-serve | wc -l'
        cmd_start_frida_daemon = 'adb shell "/data/local/tmp/frida-server -D"'

        if subprocess.check_output([cmd_check_frida], shell=True).strip() is '0':
            print('[*] Starting Frida server...')
            subprocess.Popen(cmd_start_frida_daemon, stdin=subprocess.PIPE, shell=True)
        time.sleep(1)

    @staticmethod
    def terminate():
        cmd_kill_frida = 'adb shell "killall -9 frida-server"'
        print('[*] Terminating frida-server...')
        subprocess.Popen(cmd_kill_frida, stdin=subprocess.PIPE, shell=True)


class BadadaShell(cmd.Cmd):
    default_rpc_methods = None
    args = None
    session = None
    script = None
    log = None
    usb_device = None

    def __init__(self):
        cmd.Cmd.__init__(self)

        self.aliases = {
            'exit': self.do_quit
        }

        parser = argparse.ArgumentParser(description='Badada arguments')
        parser.add_argument('processToHook', help='Name of the process to be attached')
        parser.add_argument('-j', '--javascript', help='Path to javascript code file to inject')
        parser.add_argument('--log', help='Save output to path')
        parser.add_argument('--spawn', action='store_true', help='Frida injects into Zygote, spawns processToHook '
                                                                  'and waits for input. Similar to running '
                                                                  'Frida with -f flag')

        self.args = parser.parse_args()
        self.log = self.args.log
        
        print('\033[1m' + '\033[94m' + """                 ____          _____          _____          
                |  _ \   /\   |  __ \   /\   |  __ \   /\    
                | |_) | /  \  | |  | | /  \  | |  | | /  \   
                |  _ < / /\ \ | |  | |/ /\ \ | |  | |/ /\ \  
                | |_) / ____ \| |__| / ____ \| |__| / ____ \ 
                |____/_/    \_\_____/_/    \_\_____/_/    \_\\        
            """ + '\033[0m')

        print('[*] Ensuring adb server is running...')
        subprocess.call(['adb', 'start-server'])

        print('[*] Waiting until the device is connected to the USB port...')
        os.system('adb wait-for-device')

        time.sleep(0.5)

        if self.args.processToHook != 'Gadget':
            if subprocess.check_output(['adb shell "[ -f /data/local/tmp/frida-server ]; echo \\$?"'],
                                       shell=True).strip() is not '0':

                print('[-] frida-server does not exist in /data/local/tmp/frida-server')
                return

            self.frida_server = FridaProcess()
            self.frida_server.run()
        
        print('[*] Attaching USB Device')

        try:
            self.usb_device = frida.get_usb_device(2)  # timeout = 2

        except frida.TimedOutError:
            print('[-] Failed to attach to USB Device.')
            return

        if not self.usb_device:
            print('[-] Failed to attach to USB Device.')
            return
        
        try:
            # If is digit, attach to pid
            pid = None
            if self.args.spawn:
                if self.args.processToHook.isdigit():
                    print('[-] To spawn the process you must pass the process name')
                    return

                print('[*] Spawning %s' % (self.args.processToHook))
                pid = self.usb_device.spawn([self.args.processToHook])

                print('[*] Attaching to %s' % (self.args.processToHook))
                self.session = self.usb_device.attach(pid)

            elif self.args.processToHook.isdigit():
                print('[*] Attaching to ' + self.args.processToHook + " pid")
                self.session = self.usb_device.attach(int(self.args.processToHook))

            else:
                print('[*] Attaching to ' + self.args.processToHook + " process")
                self.session = self.usb_device.attach(self.args.processToHook)

        except frida.ServerNotRunningError:
            print('[-] Unable to connect to frida-server.')
            return

        except frida.ProcessNotFoundError:
            print('[-] Unable to find ' + self.args.processToHook + ' to attach.')
            return

        print('[*] Loading default RPC methods')
        self.default_rpc_methods = self.load_script(os.path.join(
            os.path.dirname(__file__), 'scripts/', 'scriptsRPC.js'))

        self.script = None

        if self.args.javascript:
            print('[*] Loading %s' % (self.args.javascript))
            try:
                self.script = self.load_script(self.args.javascript)

            except IOError:
                print('[-] Unable to load script "' + self.args.javascript + '": file not found.')
                self.script = None
                self.args.javascript = None

        if self.args.spawn:
            print('[*] Resuming %s' % (self.args.processToHook))
            time.sleep(1)
            self.usb_device.resume(pid)

    def emptyline(self):
        pass

    def default(self, line):
        command, arg, line = self.parseline(line)

        if line[0] is '!':
            os.system(line[1:])
        elif command in self.aliases:
            self.aliases[command](arg)
        else:
            print('[-] Command not found')

    @staticmethod
    def get_file_contents(file_name):
        f = open(file_name)
        content = f.read()
        f.close()

        return content

    def on_message(self, message, data):
        if 'payload' in message.keys():
            if self.log:
                log_file = open("logs/" + self.log, 'a')
                log_file.write(str(time.asctime()))
                log_file.write(" ---> ")
                log_file.write(str(message['payload']) + '\n')
                log_file.close()
            sys.stdout.write(str(message['payload']) + '\n')
        else:
            if self.log:
                log_file = open("logs/" + self.log, 'a')
                log_file.write(str(time.asctime()))
                log_file.write(" ---> ")
                log_file.write(str(message) + '\n')
                log_file.close()
            sys.stdout.write(str(message) + '\n')

    def load_script(self, file_name):
        hook_source = self.get_file_contents(file_name)
        self.script = self.session.create_script(hook_source)
        self.script.on('message', self.on_message)
        self.script.load()

        return self.script

    def get_classes(self, contains_text):
        if not self.default_rpc_methods:
            print('[-] Seems that there is no hook')
            return

        self.default_rpc_methods.exports.getclasses(contains_text)

    def get_methods_with_signature(self, class_name, contains_text):
        if not self.default_rpc_methods:
            print('[-] Seems that there is no hook')
            return

        self.default_rpc_methods.exports.getmethods(class_name, contains_text)

    def search_method(self, method_name):
        if not self.default_rpc_methods:
            print('[-] Seems that there is no hook')
            return
      
        self.default_rpc_methods.exports.searchmethod(method_name)
    
    def cleanup(self):
        if self.default_rpc_methods:
            print('[*] Unloading default RPC methods')
            try:
                self.default_rpc_methods.unload()
            except frida.InvalidOperationError:
                pass
            finally:
                self.default_rpc_methods = None

        if self.script:
            print('[*] Unloading current script...')
            try:
                self.script.unload()
            except frida.InvalidOperationError:
                pass
            finally:
                self.script = None

        print('[*] Detaching current session.')
        if self.session is not None:
            try:
                self.session.detach()
            except frida.InvalidOperationError:
                pass
            finally:
                self.session = None
        
        if self.args.processToHook != 'Gadget':
            try:
                self.frida_server.terminate()
            except Exception:
                pass
    
        print('[*] Exiting...\n' + '[*] Thanks for using Badada! ' + 'Bye \\o/')

    def do_quit(self, in_args):
        raise SystemExit

    @staticmethod
    def help_quit():
        print('\n'.join(['Exit Frida']))

    def do_reload(self):
        if not self.args.javascript:
            print('[*] There is no script to reload.')
            return
        
        if self.script:
            print('[*] Unloading current script...')
            self.script.unload()
            self.script = None

        print('[*] Reloading %s' % (self.args.javascript))
        try:
            self.script = self.load_script(self.args.javascript)
        except IOError:
            print('[-] Unable load script "' + self.args.javascript + '": file not found.')
            self.script = None

    @staticmethod
    def help_reload():
        print('\nReloads current script for changes\n')

    def do_unload(self):
        if self.args.javascript and self.script:
            print('[*] Unloading current script...')
            self.script.unload()
            self.script = None
        else:
            print('[-] There is no script to unload')

    def do_load(self, in_args):
        args = in_args.strip().split(" ")
        if len(args) != 1 or len(args[0]) == 0:
            print('\n[-] Usage load [<script.js>]\n')

        else:
            if self.args.javascript and self.script:
                print('[*] Unloading current script...')
                self.script.unload()
                self.script = None
            
            print('[*] Loading new script...')
            self.args.javascript = args[0]
            
            try:
                self.script = self.load_script(self.args.javascript)
            except IOError:
                print('[-] Unable load script "' + self.args.javascript + '": file not found.')
                self.script = None

    @staticmethod
    def help_load():
        print('\nLoads a javascript code to be injected.\n')

    def do_classes(self, in_args):
        args = in_args.strip().split(" ")
        if len(args) > 1:
                print('\n[-] Usage getclasses [<contains_this>]')

        elif len(args) == 0:
            self.get_classes('')

        else:
            self.get_classes(args[0])

    def do_searchmethod(self, method_name):
        if not method_name:
            print('\nYou have to specify a method to search for')
            return

        self.search_method(method_name)

    @staticmethod
    def help_classes():
        print('\n'.join(['Show all classes filtered by [<contains_this>]']))

    def do_methods(self, in_args):
        args = in_args.strip().split(" ")
        if len(args) < 1:
            print('\n[-] Usage: getmethods <className> [<contains_this>]\n')

        elif len(args) == 1:
            self.get_methods_with_signature(args[0], "")
        else:
            self.get_methods_with_signature(args[0], args[1])

    @staticmethod
    def help_methods():
        print('\n'.join(['Show all methods from <class_name> [<contains_this>]']))

    @staticmethod
    def help_clear():
        print('\n'.join(['Clears the terminal screen.']))

    def do_hook(self, in_args):
        args = in_args.strip().split(" ")
        if len(args) < 1 or len(args[0]) == 0:
            print('\n[-] Usage hook <process_to_hook>\n')

        else:
            if self.default_rpc_methods:
                print('[*] Unloading default RPC methods')
                try:
                    self.default_rpc_methods.unload()
                except frida.InvalidOperationError:
                    pass
                finally:
                    self.default_rpc_methods = None

            if self.args.javascript and self.script:
                print('[*] Unloading current script...')
                self.script.unload()
                self.script = None

            print('[*] Detaching current session.')
            self.session.detach()

            print('[*] Attaching to ' + args[0] + '.')

            try:
                self.session = self.usb_device.attach(args[0])
                self.default_rpc_methods = self.load_script(
                    os.path.join(os.path.dirname(__file__), 'scripts/', 'scriptsRPC.js'))

                self.args.javascript = None
            except frida.ServerNotRunningError:
                print('[-] Unable to connect to frida-server.')
                return
            except frida.ProcessNotFoundError:
                print('[-] Unable to find the process to attach.')

    @staticmethod
    def help_hook():
        print('\n'.join(['Hooks a new process']))


if __name__ == '__main__':
    prompt = BadadaShell()
    prompt.prompt = '\033[1m' + '\033[92m' + 'badada> ' + '\033[0m'

    try:
        prompt.cmdloop()
    except KeyboardInterrupt as err:
        print('[*] CTRL+C detected...')
    except Exception as e:
        print('[-] %s' % (e.message.capitalize()))
    finally:
        prompt.cleanup()
